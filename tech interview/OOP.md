### ***객체지향 프로그래밍이란?***
객체지향 프로그래밍은 컴퓨터 프로그래밍 패러다임 중 하나로, 프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법입니다.

---

### ***객체지향 프로그래밍의 4가지 특징***
객체지향 프로그래밍의 4가지 특징으로 추상화, 캡슐화, 상속, 다형성이 있습니다.

먼저 추상화는 객체들이 공통적으로 필요로하는 속성이나 동작을 하나로 추출하는 작업입니다. 캡슐화는 정보 은닉화를 통해 높은 응집도, 낮은 결합도를 유지할 수 있도록 설계하는 것입니다. 상속은 부모클래스의 속성과 기능을 자식 클래스에서 그대로 이어받아 사용할 수 있게하고 기능의 일부분을 변경해야 할 경우 해당 기능만 다시 수정(정의)하여 사용할 수 있게 하는 것입니다. 다형성은 같은 형태이지만 다른 기능을 하는 것으로 서로 다른 클래스의 객체가 같은 동작 수행 명령을 받았을 때, 각자의 특성에 맞는 방식으로 동작합니다.

<details>
<summary>설명</summary>

#### 추상화

- 객체들이 공통적으로 필요로 하는 속성이나 동작을 하나로 추출해내는 작업
- 즉, 세부적인 사물들의 공통적인 특징을 파악 후 하나의 묶음으로 만들어 내는 것
- 추상적인 개념에 의존해 설계해야 유연함을 갖출 수 있다.

#### 캡슐화

- 정보 은닉화를 통해 높은 응집도, 낮은 결합도를 유지할 수 있도록 설계하는 것
- 한 곳의 변화가 일어나도 다른 곳에 미치는 사이드 이펙트를 최소화 시키는 것
- 즉, 어떤 동작에 대한 객체 내부의 구현이 어떻게 되어있는지 감추는 것


> ***결합도*** : 어떤 기능을 실행할 때 다른 클래스나 모듈에 얼마나 의존적인지를 나타내느 지표
> ***응집도*** : 해당 기능을 수행하기 위해 얼마만큼의 연관된 책임과 아이디어가 뭉쳐있는지를 나타내는 지표 (지나치게 많은 일을하면 응집도가 낮은 것)


#### 상속

- 자식 클래스가 부모 클래스의 필드나 메소드를 그대로 물려받아 사용하는 것
- 자식 클래스를 외부로부터 은닉하는 캡슐화의 일종
- 상속을 활용하면 부모 클래스의 구현을 활용함을써, 코드 재사용이 용이해짐
- 하지만 상속을 통한 재사용을 할 때 나타나는 단점이 명백해 OOP에서 코드 재사용을 목적으로 하는 상속 행위는 엄격히 금한다.
    - 단점
        1. 부모 클래스의 변경이 불편해짐 : 부모 클래스에 의존하는 자식 클래스가 많을 때 부모 클래스의 변경이 필요하다면, 이를 의존하는 자식 클래스들이 영향을 받게됨.
        2. 불필요한 클래스의 증가 : 유사 기능 확장시, 필요 이상의 불필요한 클래스를 만들어야 할 수 있음
        3. 잘못된 상속 사용 : 같은 종류가 아닌 클래스의 구현을 재사용하기 위해 상속 → 상속받는 클래스가 부모 클래스와 IS-A 관계가 아닐 때
    - 이러한 단점들은 구성(Composition)을 통해 해결

#### 다형성

- 서로 다른 클래스의 객체가 같은 동작 수행 명령을 받았을 때, 각자의 특성에 맞는 방식으로 동작하는 것
- 객체지향 패러다임의 핵심으로 상속과 시너지가 좋다.
- 다형성 구현을 통해 코드를 간결하게 해주고, 유연셩을 갖추게 해줌.
</details>

---

### ***객체지향 프로그래밍의 장단점***
객체지향 프로그래밍의 장점으로는 유지보수가 용이하고 코드의 재사용성이 좋습니다. 또한, 독립적인 객체를 사용함으로써 개발의 생산성이 향상되고 테스트하는 것도 용이합니다. 하지만 객체지향 프로그래밍의 대부분의 장점은 객체간의 결합도가 낮을 때 적용되기 때문에 설계 단계에서 많은 시간과 비용이 소모되며 절차지향 언어보다 비교적 실행속도가 느립니다.

<details>
<summary>설명</summary>

#### 👍 코드의 재사용성이 좋다.
하나의 객체에 프로그램에 필요한 데이터 구조와 데이터를 다루는 방법을 정의해놓은 뒤, 필요에 따라 호출해 사용하기 때문에 코드의 재사용성이 좋다.

#### 👍 유지보수가 뛰어나다.
객체간 결합도가 낮아 변경 시에도 상호작용 관계에 있는 다른 객체들에게 영향을 최소한으로 미치기 때문에 수정이 필요한 코드가 있을 경우 다른 코드를 신경 쓰지 않고 해당 구간만을 수정하면 된다.

#### 👍 개발의 생산성이 향상되고 테스트가 용이하다.
잘 설계된 독립적인 객체를 사용하기 때문에 개발의 생산성이 향상되고 테스트가 용이하다.

#### 👎 설계 단계에서 많은 시간과 비용이 소모된다.
객체지향 프로그래맹의 대부분의 장점은 객체간의 결합도가 낮을 때 적용되기 때문에 프로그램에 사용될 객체들의 결합도를 낮추는 과정이 필수이므로 설계 단계에서 많은 시간과 비용이 소모된다.

#### 👎 실행속도가 느리다.
프로그램의 알고리즘대로 실행될 코드가 바로 구현된 절차지향과는 달리 객체지향은 실행될 코드를 필요할 때 마다 객체에서 호출해서 사용하는 식으로 진행되기 때문에 코드의 실행처리속도가 비교적 느리다.

</details>

---

### ***객체지향 프로그래밍 설계 원칙 SOLID***
SOLID는 각각 SRP, OCP, LSP, ISP, DIP의 앞 글자를 딴 것입니다.
먼저 SRP인 단일 책임의 원칙은 클래스는 하나의 기능만 가지며 클래스가 제공하는 모든 서비스는 그 하나의 책임을 수행하는데 집중되어야 한다는 원칙입니다.
OCP인 개방폐쇄의 원칙은 확장에는 열려있고, 변경에는 닫혀있어야한다는 원칙입니다.
LSP는 리스코브 치환의 원칙으로 부모 객체와 이를 상속한 자식 개체가 있을 때 부모 객체를 호출하는 동작에서 자식 객체가 부모 객체를 완전히 대체할 수 있어야합니다.
ISP는 인터페이스 분리의 원칙으로 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 원칙입니다.
마지막으로 DIP는 의존성 역전의 원칙으로 객체는 객체보다 인터페이스에 의존해야한다는 원칙입니다.


<details>
<summary>설명</summary>

입증된 객체지향 디자인 원리들을 사용하면 좀 더 유지보수하기 쉽고, 유연하고, 확장이 쉬운 소프트웨어를 만들 수 있다.

#### SRP (단일 책임의 원칙: Single Responseibility Principle)
- 작성된 클래스는 하나의 기능만 가지며 클래스가 제공하는 모든 서비스는 그 하나의 책임을 수행하는데 집중되어야 한다.
- 이는 어떤 변화에 의해 클래스를 변경해야하는 이유는 오직 하나뿐이어야 함을 의미
- 책임을 적절히 분배함으로써 코드의 가독성 향상, 유지보수 용이하다.
- 다른 원리들을 적용하는 기초
- 실무에서는 프로세스가 복잡하고 다양하기 때문에 변경이 빈번한데 경험이 많지 않거나 도메인에 대한 이해가 부족하면 SRP에서 멀어진다.

#### OCP (개방 폐쇄의 원칙: Open Close Principle)
- 소프트웨어의 구성요소(컴포넌트, 클래스, 모듈, 함수)는 확장에는 열려있고, 변경에는 닫혀있어야함.
- 즉, 요구사항의 변경이나 추가사항이 발생하더라도 기존의 구성요소는 수정이 일어나지 말아야 하며, 기존 구성요소를 쉽게 확장해서 재사용할 수 있어야 한다.
- OCP를 가능케 하는 중요 메커니즘은 추상화와 다형성
- 객체지향의 장점을 극대화하는 아주 중요한 원리

#### LSP (리스코브 치환의 원칙: The Liskov Subsituation Principle)
- 서브 타입은 언제나 기반 타입으로 교체할 수 있어야 한다. 즉, 서브 타입은 언제나 기반 타입과 호환될 수 있어야한다.
- 서브 타입은 기반 타입이 약속한 규약을 지켜야 한다.

#### ISP (인터페이스 분리의 원칙: Interface Segregation Principle)
- 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야한다.
- 즉, 어떤 클래스가 다른 클래스에 종속될 때에는 가능한 최소한의 인터페이스만을 사용해야한다.
- `하나의 일반적인 인터페이스보다는 여러 개의 구체적인 인터페이스가 낫다`라고 정의할 수도 있음.

#### DIP (의존성 역전 원칙: Dependency Inversion Principle)
- 객체는 저수준 모듈보다 고수준 모듈에 의존해야한다.
    > 저수준 모듈: 구현된 객체
    > 고수준 모듈: 인터페이스와 같은 객체의 형태나 추상적 개념
- 즉, 객체는 객체보다 인터페이스에 의존해야한다.
- 유연한 인터페이스가 더욱 확장 가능성이 높기 때문에 고수준 모듈인 인터페이스에 의존하는 DIP는 코드의 확장성 및 재사용성을 추구하기 위한 원칙

</details>